/**
 * @file mavlink_generated_devices.c
 * @brief Auto-generated device initialization and management
 *
 * Generated from: h753_full.yaml
 * Platform: STM32
 * Generated: 2025-11-15T14:28:39.589378
 * Checksum: 7edaf5a6c0f0ad21
 * Generator Version: 1.0.0
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 * Any changes will be overwritten on next generation.
 */

#include "mavlink_generated_config.h"

/* Include parameter implementation in this compilation unit */
#define MAVLINK_GENERATED_PARAMS_IMPLEMENTATION
#include "mavlink_generated_params.h"

/* Include platform-specific headers */
#ifdef STM32H7xx
#include "stm32h7xx_hal.h"
#elif defined(STM32F4xx)
#include "stm32f4xx_hal.h"
#elif defined(STM32F7xx)
#include "stm32f7xx_hal.h"
#endif

/* Include motor controllers */
#include "motors/servo_controller.h"
#include "motors/dc_controller.h"
#include "motors/robomaster_controller.h"
#include "motors/rs485_controller.h"

/* Include hardware manager */
#include "hal/hardware_manager.h"

/* ========================================================================== */
/*  SERVO CONFIGURATION DATA                                                  */
/* ========================================================================== */

const mavlink_gen_servo_config_t mavlink_gen_servo_configs[MAVLINK_GEN_SERVO_COUNT] = {
    {
        .id = 1,
        .name = "servo_1",
        .timer_id = 15,
        .channel = TIM_CHANNEL_1,
        .min_pulse_us = 500,
        .max_pulse_us = 2500,
        .min_angle = -90.000000f,
        .max_angle = 90.000000f,
        .neutral_angle = 0.000000f,
    },
    {
        .id = 2,
        .name = "servo_2",
        .timer_id = 15,
        .channel = TIM_CHANNEL_2,
        .min_pulse_us = 500,
        .max_pulse_us = 2500,
        .min_angle = -90.000000f,
        .max_angle = 90.000000f,
        .neutral_angle = 0.000000f,
    },
};

/* Servo controller storage */
static motor_controller_t servo_controllers_storage[MAVLINK_GEN_SERVO_COUNT];
static servo_private_t servo_private_data[MAVLINK_GEN_SERVO_COUNT];
static motor_controller_t* servo_controllers[MAVLINK_GEN_SERVO_COUNT];

/* ========================================================================== */
/*  DC MOTOR CONFIGURATION DATA                                               */
/* ========================================================================== */

const mavlink_gen_dc_motor_config_t mavlink_gen_dc_motor_configs[MAVLINK_GEN_DC_MOTOR_COUNT] = {
    {
        .id = 10,
        .name = "dc_motor_left",
        .timer_id = 3,
        .channel = TIM_CHANNEL_1,
        .dir_pin = "PF3",
        .max_rpm = 15.000000f,
        .has_encoder = true,
        .encoder_ppr = 8192,
        .direction_inverted = false,
    },
    {
        .id = 11,
        .name = "dc_motor_right",
        .timer_id = 3,
        .channel = TIM_CHANNEL_2,
        .dir_pin = "PF4",
        .max_rpm = 15.000000f,
        .has_encoder = true,
        .encoder_ppr = 8192,
        .direction_inverted = false,
    },
};

/* DC motor controller storage */
static motor_controller_t dc_motor_controllers_storage[MAVLINK_GEN_DC_MOTOR_COUNT];
static dc_motor_private_t dc_motor_private_data[MAVLINK_GEN_DC_MOTOR_COUNT];
static motor_controller_t* dc_motor_controllers[MAVLINK_GEN_DC_MOTOR_COUNT];

/* ========================================================================== */
/*  ROBOMASTER MOTOR CONFIGURATION DATA                                       */
/* ========================================================================== */

const mavlink_gen_robomaster_config_t mavlink_gen_robomaster_configs[MAVLINK_GEN_ROBOMASTER_COUNT] = {
    {
        .id = 20,
        .name = "gimbal_yaw",
        .can_id = 0x205,
        .motor_type = ROBOMASTER_MOTOR_TYPE_GM6020,
        .max_rpm = 10.000000f,
        .max_current = 10000 / 1000.0f,
    },
    {
        .id = 21,
        .name = "chassis_wheel",
        .can_id = 0x201,
        .motor_type = ROBOMASTER_MOTOR_TYPE_M3508,
        .max_rpm = 10.000000f,
        .max_current = 10000 / 1000.0f,
    },
};

/* RoboMaster controller storage */
static motor_controller_t robomaster_controllers_storage[MAVLINK_GEN_ROBOMASTER_COUNT];
static robomaster_private_t robomaster_private_data[MAVLINK_GEN_ROBOMASTER_COUNT];
static motor_controller_t* robomaster_controllers[MAVLINK_GEN_ROBOMASTER_COUNT];

/* ========================================================================== */
/*  RS485 MOTOR CONFIGURATION DATA                                            */
/* ========================================================================== */

const mavlink_gen_rs485_config_t mavlink_gen_rs485_configs[MAVLINK_GEN_RS485_MOTOR_COUNT] = {
    {
        .id = 30,
        .name = "conveyor_motor_1",
        .uart_port = 1,
        .rs485_device_id = 1,
        .motor_index = 0,
        .control_mode = RS485_MODE_VELOCITY,
        .max_rps = 100.000000f,
    },
    {
        .id = 31,
        .name = "conveyor_motor_2",
        .uart_port = 1,
        .rs485_device_id = 1,
        .motor_index = 1,
        .control_mode = RS485_MODE_VELOCITY,
        .max_rps = 100.000000f,
    },
    {
        .id = 32,
        .name = "lift_motor",
        .uart_port = 1,
        .rs485_device_id = 1,
        .motor_index = 2,
        .control_mode = RS485_MODE_VELOCITY,
        .max_rps = 100.000000f,
    },
};

/* RS485 controller storage */
static motor_controller_t rs485_controllers_storage[MAVLINK_GEN_RS485_MOTOR_COUNT];
static rs485_private_t rs485_private_data[MAVLINK_GEN_RS485_MOTOR_COUNT];
static motor_controller_t* rs485_controllers[MAVLINK_GEN_RS485_MOTOR_COUNT];

/* ========================================================================== */
/*  IMU SENSOR CONFIGURATION DATA                                             */
/* ========================================================================== */


/* ========================================================================== */
/*  GPS MODULE CONFIGURATION DATA                                             */
/* ========================================================================== */


/* ========================================================================== */
/*  ANALOG SENSOR CONFIGURATION DATA                                          */
/* ========================================================================== */


/* ========================================================================== */
/*  DEVICE NAME LOOKUP                                                        */
/* ========================================================================== */

const char* mavlink_gen_get_device_name(uint8_t device_id) {
    if (device_id == 1) return "servo_1";
    if (device_id == 2) return "servo_2";
    if (device_id == 10) return "dc_motor_left";
    if (device_id == 11) return "dc_motor_right";
    if (device_id == 20) return "gimbal_yaw";
    if (device_id == 21) return "chassis_wheel";
    if (device_id == 30) return "conveyor_motor_1";
    if (device_id == 31) return "conveyor_motor_2";
    if (device_id == 32) return "lift_motor";
    return NULL;
}

/* ========================================================================== */
/*  DEVICE INITIALIZATION                                                     */
/* ========================================================================== */

int mavlink_gen_init_all_devices(void) {
    int result = 0;

    /* Initialize servos */
    for (int i = 0; i < MAVLINK_GEN_SERVO_COUNT; i++) {
        const mavlink_gen_servo_config_t* cfg = &mavlink_gen_servo_configs[i];

        servo_config_t servo_cfg = {
            .id = cfg->id,
            .initial_offset = 0.0f,
            .min_angle = cfg->min_angle,
            .max_angle = cfg->max_angle,
            .pulse_min_us = cfg->min_pulse_us,
            .pulse_max_us = cfg->max_pulse_us,
            .pulse_neutral_us = (cfg->min_pulse_us + cfg->max_pulse_us) / 2,
            .direction_inverted = false,
            .max_velocity_deg_per_s = 120.0f,
            .max_acceleration_deg_per_s2 = 240.0f,
            .watchdog_timeout_ms = 1000,
            .startup_angle_deg = cfg->neutral_angle,
            .start_disabled = false,
            .failsafe_behavior = SERVO_FAILSAFE_NEUTRAL,
        };

        error_code_t err = servo_controller_create(
            cfg->id,
            cfg->timer_id,
            cfg->channel,
            &servo_cfg,
            &servo_controllers_storage[i],
            &servo_private_data[i]
        );

        if (err == ERROR_OK) {
            servo_controllers[i] = &servo_controllers_storage[i];
        } else {
            servo_controllers[i] = NULL;
            result = -1;
            /* Continue to initialize other devices */
        }
    }

    /* Initialize DC motors */
    for (int i = 0; i < MAVLINK_GEN_DC_MOTOR_COUNT; i++) {
        const mavlink_gen_dc_motor_config_t* cfg = &mavlink_gen_dc_motor_configs[i];

        dc_motor_config_t dc_cfg = {
            .id = cfg->id,
            // Speed PID gains
            .speed_kp = 0.1f,
            .speed_ki = 0.05f,
            .speed_kd = 0.0f,
            .speed_max_integral = 0.3f,
            .speed_max_output = 1.0f,
            // Position PID gains
            .position_kp = 0.5f,
            .position_ki = 0.0f,
            .position_kd = 0.1f,
            .position_max_integral = 100.0f,
            .position_max_output = 10.0f,
            // Limits
            .max_speed_rad_s = 15.0f,
            .max_acceleration_rad_s2 = 50.0f,
            .position_limit_min_rad = -314.159f,
            .position_limit_max_rad = 314.159f,
            .use_position_limits = true,
            // Control
            .watchdog_timeout_ms = 1000,
            .control_period_ms = 10,
            .direction_inverted = cfg->direction_inverted,
        };

        error_code_t err = dc_motor_controller_create(
            cfg->id,
            cfg->timer_id,
            cfg->channel,
            &dc_cfg,
            &dc_motor_controllers_storage[i],
            &dc_motor_private_data[i]
        );

        if (err == ERROR_OK) {
            dc_motor_controllers[i] = &dc_motor_controllers_storage[i];
        } else {
            dc_motor_controllers[i] = NULL;
            result = -1;
        }
    }

    /* Initialize RoboMaster motors */
    for (int i = 0; i < MAVLINK_GEN_ROBOMASTER_COUNT; i++) {
        const mavlink_gen_robomaster_config_t* cfg = &mavlink_gen_robomaster_configs[i];

        robomaster_config_t rm_cfg = {
            .id = cfg->id,
            .can_id = cfg->can_id,
            // Angle PID gains
            .angle_kp = 0.1f,
            .angle_ki = 0.0f,
            .angle_kd = 0.0f,
            // Speed PID gains (tunable via MAVLink params)
            .speed_kp = 50.0f,
            .speed_ki = 0.1f,
            .speed_kd = 0.0f,
            // Limits
            .max_speed_rad_s = 10.0f,
            .max_acceleration_rad_s2 = 30.0f,
            .watchdog_timeout_ms = 500,
        };

        error_code_t err = robomaster_controller_create(
            cfg->id,
            &rm_cfg,
            &robomaster_controllers_storage[i],
            &robomaster_private_data[i]
        );

        if (err == ERROR_OK) {
            robomaster_controllers[i] = &robomaster_controllers_storage[i];
        } else {
            robomaster_controllers[i] = NULL;
            result = -1;
        }
    }

    /* Initialize RS485 motors */
    for (int i = 0; i < MAVLINK_GEN_RS485_MOTOR_COUNT; i++) {
        const mavlink_gen_rs485_config_t* cfg = &mavlink_gen_rs485_configs[i];

        rs485_config_t rs485_cfg = {
            .id = cfg->id,
            .rs485_device_id = cfg->rs485_device_id,
            .motor_index = cfg->motor_index,
            .uart_id = cfg->uart_port,
            .control_mode = cfg->control_mode,
            .max_rps = cfg->max_rps,
            .max_acceleration_rps2 = 200.0f,
            .max_count = 8192,
            .max_rotation = 100,
            .watchdog_timeout_ms = 1000,
            .retry_count = 3,
        };

        error_code_t err = rs485_controller_create(
            cfg->id,
            &rs485_cfg,
            &rs485_controllers_storage[i],
            &rs485_private_data[i]
        );

        if (err == ERROR_OK) {
            rs485_controllers[i] = &rs485_controllers_storage[i];
        } else {
            rs485_controllers[i] = NULL;
            result = -1;
        }
    }

    return result;
}

/* ========================================================================== */
/*  DEVICE UPDATE                                                             */
/* ========================================================================== */

int mavlink_gen_update_all_devices(void) {
    static uint32_t last_time_ms = 0;
    uint32_t current_time_ms = HAL_GetTick();
    float delta_time = (last_time_ms == 0) ? 0.01f : (current_time_ms - last_time_ms) / 1000.0f;
    last_time_ms = current_time_ms;

    /* Update servos */
    for (int i = 0; i < MAVLINK_GEN_SERVO_COUNT; i++) {
        if (servo_controllers[i]) {
            motor_update(servo_controllers[i], delta_time);
        }
    }

    /* Update DC motors */
    for (int i = 0; i < MAVLINK_GEN_DC_MOTOR_COUNT; i++) {
        if (dc_motor_controllers[i]) {
            motor_update(dc_motor_controllers[i], delta_time);
        }
    }

    /* Update RoboMaster motors */
    for (int i = 0; i < MAVLINK_GEN_ROBOMASTER_COUNT; i++) {
        if (robomaster_controllers[i]) {
            motor_update(robomaster_controllers[i], delta_time);
        }
    }

    /* Update RS485 motors */
    for (int i = 0; i < MAVLINK_GEN_RS485_MOTOR_COUNT; i++) {
        if (rs485_controllers[i]) {
            motor_update(rs485_controllers[i], delta_time);
        }
    }

    return 0;
}

/* ========================================================================== */
/*  EMERGENCY STOP                                                            */
/* ========================================================================== */

void mavlink_gen_emergency_stop_all(void) {
    /* Stop servos */
    for (int i = 0; i < MAVLINK_GEN_SERVO_COUNT; i++) {
        if (servo_controllers[i]) {
            motor_emergency_stop(servo_controllers[i]);
        }
    }

    /* Stop DC motors */
    for (int i = 0; i < MAVLINK_GEN_DC_MOTOR_COUNT; i++) {
        if (dc_motor_controllers[i]) {
            motor_emergency_stop(dc_motor_controllers[i]);
        }
    }

    /* Stop RoboMaster motors */
    for (int i = 0; i < MAVLINK_GEN_ROBOMASTER_COUNT; i++) {
        if (robomaster_controllers[i]) {
            motor_emergency_stop(robomaster_controllers[i]);
        }
    }

    /* Stop RS485 motors */
    for (int i = 0; i < MAVLINK_GEN_RS485_MOTOR_COUNT; i++) {
        if (rs485_controllers[i]) {
            motor_emergency_stop(rs485_controllers[i]);
        }
    }
}

/* ========================================================================== */
/*  UNIFIED MOTOR ACCESS                                                      */
/* ========================================================================== */

/**
 * @brief Get motor controller by ID
 * @param motor_id Motor ID (1-255)
 * @return Pointer to motor controller, or NULL if not found
 */
motor_controller_t* mavlink_gen_get_controller_by_id(uint8_t motor_id) {
    /* Servo motors: 1-9 */
    if (motor_id >= 1 && motor_id <= 9) {
        for (int i = 0; i < MAVLINK_GEN_SERVO_COUNT; i++) {
            if (servo_controllers[i] && servo_controllers[i]->id == motor_id) {
                return servo_controllers[i];
            }
        }
    }

    /* DC motors: 10-15 */
    if (motor_id >= 10 && motor_id <= 15) {
        for (int i = 0; i < MAVLINK_GEN_DC_MOTOR_COUNT; i++) {
            if (dc_motor_controllers[i] && dc_motor_controllers[i]->id == motor_id) {
                return dc_motor_controllers[i];
            }
        }
    }

    /* RoboMaster motors: 20-29 */
    if (motor_id >= 20 && motor_id <= 29) {
        for (int i = 0; i < MAVLINK_GEN_ROBOMASTER_COUNT; i++) {
            if (robomaster_controllers[i] && robomaster_controllers[i]->id == motor_id) {
                return robomaster_controllers[i];
            }
        }
    }

    /* RS485 motors: 30-49 */
    if (motor_id >= 30 && motor_id <= 49) {
        for (int i = 0; i < MAVLINK_GEN_RS485_MOTOR_COUNT; i++) {
            if (rs485_controllers[i] && rs485_controllers[i]->id == motor_id) {
                return rs485_controllers[i];
            }
        }
    }

    return NULL;
}
