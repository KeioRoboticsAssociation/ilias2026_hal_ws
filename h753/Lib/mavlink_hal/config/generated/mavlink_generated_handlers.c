/**
 * @file mavlink_generated_handlers.c
 * @brief Auto-generated MAVLink message handlers
 *
 * Generated from: stm32h753_rover.yaml
 * Platform: STM32
 * Generated: 2025-11-11T20:26:05.902152
 * Checksum: e5e0ea3c97c446a8
 * Generator Version: 1.0.0
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 * Any changes will be overwritten on next generation.
 */

#include "mavlink_generated_config.h"
#include "mavlink_generated_params.h"

/* Include MAVLink library */
#include "mavlink/c_library_v2/common/mavlink.h"

/* Include motor controllers */
#include "App/motors/servo_controller.h"
#include "App/motors/dc_controller.h"
#include "App/motors/robomaster_controller.h"
#include "App/motors/rs485_controller.h"

#include <string.h>

/* ========================================================================== */
/*  RC_CHANNELS_OVERRIDE HANDLER                                              */
/* ========================================================================== */

/**
 * @brief Handle RC_CHANNELS_OVERRIDE message (ID 70)
 *
 * Map RC channels to device commands based on device ID.
 * Channel values: 0-1000 = disabled, 1000-2000 = control range
 */
void mavlink_gen_handle_rc_channels_override(const mavlink_message_t* msg) {
    mavlink_rc_channels_override_t rc;
    mavlink_msg_rc_channels_override_decode(msg, &rc);

    /* RC channels 1-8 map to device IDs 1-8 (typically servos) */
    uint16_t channels[8] = {
        rc.chan1_raw, rc.chan2_raw, rc.chan3_raw, rc.chan4_raw,
        rc.chan5_raw, rc.chan6_raw, rc.chan7_raw, rc.chan8_raw
    };

    /* Map to servos (IDs 1-9) */
    for (int i = 0; i < MAVLINK_GEN_SERVO_COUNT && i < 8; i++) {
        uint8_t device_id = mavlink_gen_servo_configs[i].id;

        if (device_id >= 1 && device_id <= 8) {
            uint16_t pwm = channels[device_id - 1];

            if (pwm >= 1000 && pwm <= 2000) {
                /* Convert PWM to angle */
                float angle = mavlink_gen_servo_configs[i].min_angle +
                    (pwm - 1000) * (mavlink_gen_servo_configs[i].max_angle -
                                     mavlink_gen_servo_configs[i].min_angle) / 1000.0f;

                /* Set servo angle (implementation-specific) */
                /* servo_controller_set_angle(servo_controllers[i], angle); */
            }
        }
    }

    /* Map to DC motors (IDs 10-15) */
    for (int i = 0; i < MAVLINK_GEN_DC_MOTOR_COUNT && i < 6; i++) {
        uint8_t device_id = mavlink_gen_dc_motor_configs[i].id;

        /* DC motors could use extended channels or custom mapping */
        /* Implementation depends on your specific requirements */
    }
}

/* ========================================================================== */
/*  MANUAL_CONTROL HANDLER                                                    */
/* ========================================================================== */

/**
 * @brief Handle MANUAL_CONTROL message (ID 69)
 *
 * Manual control with joystick axes (x, y, z, r) and buttons.
 * Values range: -1000 to +1000 for axes
 */
void mavlink_gen_handle_manual_control(const mavlink_message_t* msg) {
    mavlink_manual_control_t manual;
    mavlink_msg_manual_control_decode(msg, &manual);

    /* Axes: x, y, z, r (range: -1000 to +1000) */
    float x_norm = manual.x / 1000.0f;  /* Forward/backward */
    float y_norm = manual.y / 1000.0f;  /* Left/right */
    float z_norm = manual.z / 1000.0f;  /* Throttle */
    float r_norm = manual.r / 1000.0f;  /* Rotation */

    /* Example: Map to drive motors (customize for your robot) */
    /* Differential drive example (IDs 10-11) */
    float left_speed = (z_norm + r_norm) * mavlink_gen_dc_motor_configs[0].max_rpm;
    float right_speed = (z_norm - r_norm) * mavlink_gen_dc_motor_configs[1].max_rpm;

    /* Set motor speeds (implementation-specific) */
    /* dc_motor_controller_set_speed(dc_motor_controllers[0], left_speed); */
    /* dc_motor_controller_set_speed(dc_motor_controllers[1], right_speed); */

    /* Buttons can trigger special functions */
    /* uint16_t buttons = manual.buttons; */
}

/* ========================================================================== */
/*  MOTOR_COMMAND HANDLER (Custom Message ID 12004)                           */
/* ========================================================================== */

/**
 * @brief Handle MOTOR_COMMAND message (ID 12004)
 *
 * Generic motor control for all motor types (IDs 1-255).
 * Control modes: 0=position, 1=velocity, 2=current, 3=duty_cycle
 */
void mavlink_gen_handle_motor_command(const mavlink_message_t* msg) {
    /* Decode custom MOTOR_COMMAND message */
    uint8_t motor_id;
    uint8_t control_mode;
    float target_value;
    uint8_t enable;

    /* Extract fields from message payload */
    /* This assumes MOTOR_COMMAND is defined in your custom MAVLink dialect */
    motor_id = msg->payload[0];
    control_mode = msg->payload[1];
    enable = msg->payload[2];
    memcpy(&target_value, &msg->payload[3], sizeof(float));

    if (!enable) {
        /* Disable motor - set to neutral/stop */
        /* Implementation-specific */
        return;
    }

    /* Handle servo motors (IDs 1-9) */
    for (int i = 0; i < MAVLINK_GEN_SERVO_COUNT; i++) {
        if (mavlink_gen_servo_configs[i].id == motor_id) {
            if (control_mode == 0) {  /* Position mode */
                /* servo_controller_set_angle(servo_controllers[i], target_value); */
            }
            return;
        }
    }

    /* Handle DC motors (IDs 10-15) */
    for (int i = 0; i < MAVLINK_GEN_DC_MOTOR_COUNT; i++) {
        if (mavlink_gen_dc_motor_configs[i].id == motor_id) {
            switch (control_mode) {
                case 1:  /* Velocity mode */
                    /* dc_motor_controller_set_speed(dc_motor_controllers[i], target_value); */
                    break;
                case 3:  /* Duty cycle mode */
                    /* dc_motor_controller_set_duty_cycle(dc_motor_controllers[i], target_value); */
                    break;
            }
            return;
        }
    }

    /* Handle RoboMaster motors (IDs 20-29) */
    for (int i = 0; i < MAVLINK_GEN_ROBOMASTER_COUNT; i++) {
        if (mavlink_gen_robomaster_configs[i].id == motor_id) {
            switch (control_mode) {
                case 1:  /* Velocity mode */
                    /* robomaster_controller_set_speed(robomaster_controllers[i], target_value); */
                    break;
                case 2:  /* Current mode */
                    /* robomaster_controller_set_current(robomaster_controllers[i], target_value); */
                    break;
            }
            return;
        }
    }

    /* Handle RS485 motors (IDs 30-49) */
    for (int i = 0; i < MAVLINK_GEN_RS485_MOTOR_COUNT; i++) {
        if (mavlink_gen_rs485_configs[i].id == motor_id) {
            switch (control_mode) {
                case 0:  /* Position mode */
                    /* rs485_controller_set_position(rs485_controllers[i], target_value); */
                    break;
                case 1:  /* Velocity mode */
                    /* rs485_controller_set_velocity(rs485_controllers[i], target_value); */
                    break;
            }
            return;
        }
    }
}

/* ========================================================================== */
/*  PARAMETER REQUEST LIST HANDLER                                            */
/* ========================================================================== */

/**
 * @brief Handle PARAM_REQUEST_LIST message (ID 21)
 *
 * Send all parameter values to ground station
 */
void mavlink_gen_handle_param_request_list(const mavlink_message_t* msg,
                                           mavlink_channel_t chan) {
    /* Send all parameters defined in mavlink_generated_params.h */
    for (int i = 0; i < MAVLINK_GEN_PARAM_COUNT; i++) {
        const mavlink_gen_param_def_t* param = &mavlink_gen_param_defs[i];

        mavlink_message_t response;
        mavlink_msg_param_value_pack(
            MAVLINK_GEN_SYSTEM_ID,
            MAVLINK_GEN_COMPONENT_ID,
            &response,
            param->name,
            param->current_value,
            MAV_PARAM_TYPE_REAL32,
            MAVLINK_GEN_PARAM_COUNT,
            i
        );

        /* Send message (implementation-specific) */
        /* mavlink_send_message(chan, &response); */
    }
}

/* ========================================================================== */
/*  PARAMETER REQUEST READ HANDLER                                            */
/* ========================================================================== */

/**
 * @brief Handle PARAM_REQUEST_READ message (ID 20)
 *
 * Send specific parameter value
 */
void mavlink_gen_handle_param_request_read(const mavlink_message_t* msg,
                                           mavlink_channel_t chan) {
    mavlink_param_request_read_t req;
    mavlink_msg_param_request_read_decode(msg, &req);

    /* Find parameter by name or index */
    const mavlink_gen_param_def_t* param = NULL;

    if (req.param_index >= 0 && req.param_index < MAVLINK_GEN_PARAM_COUNT) {
        param = &mavlink_gen_param_defs[req.param_index];
    } else {
        /* Search by name */
        for (int i = 0; i < MAVLINK_GEN_PARAM_COUNT; i++) {
            if (strncmp(mavlink_gen_param_defs[i].name, req.param_id, 16) == 0) {
                param = &mavlink_gen_param_defs[i];
                break;
            }
        }
    }

    if (param) {
        mavlink_message_t response;
        mavlink_msg_param_value_pack(
            MAVLINK_GEN_SYSTEM_ID,
            MAVLINK_GEN_COMPONENT_ID,
            &response,
            param->name,
            param->current_value,
            MAV_PARAM_TYPE_REAL32,
            MAVLINK_GEN_PARAM_COUNT,
            req.param_index
        );

        /* Send message (implementation-specific) */
        /* mavlink_send_message(chan, &response); */
    }
}

/* ========================================================================== */
/*  PARAMETER SET HANDLER                                                     */
/* ========================================================================== */

/**
 * @brief Handle PARAM_SET message (ID 23)
 *
 * Set parameter value and apply to device
 */
void mavlink_gen_handle_param_set(const mavlink_message_t* msg,
                                  mavlink_channel_t chan) {
    mavlink_param_set_t set;
    mavlink_msg_param_set_decode(msg, &set);

    /* Find parameter */
    mavlink_gen_param_def_t* param = NULL;
    int param_index = -1;

    for (int i = 0; i < MAVLINK_GEN_PARAM_COUNT; i++) {
        if (strncmp(mavlink_gen_param_defs[i].name, set.param_id, 16) == 0) {
            param = &mavlink_gen_param_defs[i];
            param_index = i;
            break;
        }
    }

    if (param) {
        /* Validate range */
        if (set.param_value >= param->min_value && set.param_value <= param->max_value) {
            /* Update value */
            param->current_value = set.param_value;

            /* Apply to device (implementation-specific) */
            /* mavlink_gen_apply_parameter(param); */

            /* Send confirmation */
            mavlink_message_t response;
            mavlink_msg_param_value_pack(
                MAVLINK_GEN_SYSTEM_ID,
                MAVLINK_GEN_COMPONENT_ID,
                &response,
                param->name,
                param->current_value,
                MAV_PARAM_TYPE_REAL32,
                MAVLINK_GEN_PARAM_COUNT,
                param_index
            );

            /* Send message (implementation-specific) */
            /* mavlink_send_message(chan, &response); */
        }
    }
}

/* ========================================================================== */
/*  MAIN MESSAGE DISPATCHER                                                   */
/* ========================================================================== */

/**
 * @brief Dispatch MAVLink message to appropriate handler
 *
 * Call this function when a MAVLink message is received
 */
void mavlink_gen_handle_message(const mavlink_message_t* msg,
                                mavlink_channel_t chan) {
    switch (msg->msgid) {
        case MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE:
            mavlink_gen_handle_rc_channels_override(msg);
            break;

        case MAVLINK_MSG_ID_MANUAL_CONTROL:
            mavlink_gen_handle_manual_control(msg);
            break;

        case 12004:  /* MOTOR_COMMAND (custom message) */
            mavlink_gen_handle_motor_command(msg);
            break;

        case MAVLINK_MSG_ID_PARAM_REQUEST_LIST:
            mavlink_gen_handle_param_request_list(msg, chan);
            break;

        case MAVLINK_MSG_ID_PARAM_REQUEST_READ:
            mavlink_gen_handle_param_request_read(msg, chan);
            break;

        case MAVLINK_MSG_ID_PARAM_SET:
            mavlink_gen_handle_param_set(msg, chan);
            break;

        default:
            /* Unhandled message */
            break;
    }
}
