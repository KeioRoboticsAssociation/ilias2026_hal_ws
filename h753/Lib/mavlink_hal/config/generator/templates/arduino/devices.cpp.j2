/**
 * @file mavlink_generated_devices.cpp
 * @brief Auto-generated device initialization and management for Arduino
 *
 * Generated from: {{ config_file }}
 * Platform: {{ platform.type | upper }}
 * Generated: {{ generated_timestamp }}
 * Generator Version: {{ generator_version }}
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 * Any changes will be overwritten on next generation.
 */

#include "mavlink_generated_config.h"

{% if servo_count > 0 %}
#include <Servo.h>
{% endif %}

/* ========================================================================== */
/*  SERVO CONFIGURATION DATA                                                  */
/* ========================================================================== */

{% if servo_count > 0 %}
const ServoConfig servoConfigs[MAVLINK_GEN_SERVO_COUNT] = {
{% for device in devices_by_type.servo %}
    {
        .id = {{ device.id }},
        .name = "{{ device.name }}",
        .pin = {{ device.hardware.pins.pwm }},
        .min_pulse_us = {{ device.config.servo.min_pulse_us | default(1000) }},
        .max_pulse_us = {{ device.config.servo.max_pulse_us | default(2000) }},
        .min_angle = {{ device.limits.min_value | default(-90.0) | format_float }},
        .max_angle = {{ device.limits.max_value | default(90.0) | format_float }},
        .neutral_angle = {{ device.config.servo.neutral_angle | default(0.0) | format_float }},
    },
{% endfor %}
};

/* Servo instances */
static Servo servos[MAVLINK_GEN_SERVO_COUNT];
{% endif %}

/* ========================================================================== */
/*  DC MOTOR CONFIGURATION DATA                                               */
/* ========================================================================== */

{% if dc_motor_count > 0 %}
const DCMotorConfig dcMotorConfigs[MAVLINK_GEN_DC_MOTOR_COUNT] = {
{% for device in devices_by_type.dc_motor %}
    {
        .id = {{ device.id }},
        .name = "{{ device.name }}",
        .pwm_pin = {{ device.hardware.pins.pwm }},
        .dir_pin1 = {{ device.hardware.pins.dir1 }},
        .dir_pin2 = {{ device.hardware.pins.dir2 }},
        .max_rpm = {{ device.limits.max_speed | default(1000.0) | format_float }},
    },
{% endfor %}
};
{% endif %}

/* ========================================================================== */
/*  BLDC MOTOR CONFIGURATION DATA                                             */
/* ========================================================================== */

{% if bldc_motor_count > 0 %}
const BLDCMotorConfig bldcMotorConfigs[MAVLINK_GEN_BLDC_MOTOR_COUNT] = {
{% for device in devices_by_type.bldc_motor %}
    {
        .id = {{ device.id }},
        .name = "{{ device.name }}",
        .esc_pin = {{ device.hardware.pins.esc }},
        .min_throttle_us = {{ device.config.bldc_motor.min_throttle_us | default(1000) }},
        .max_throttle_us = {{ device.config.bldc_motor.max_throttle_us | default(2000) }},
    },
{% endfor %}
};

/* BLDC ESC instances */
static Servo bldcESCs[MAVLINK_GEN_BLDC_MOTOR_COUNT];
{% endif %}

/* ========================================================================== */
/*  DEVICE NAME LOOKUP                                                        */
/* ========================================================================== */

const char* mavlinkGenGetDeviceName(uint8_t deviceId) {
{% for device in devices %}
    if (deviceId == {{ device.id }}) return "{{ device.name }}";
{% endfor %}
    return nullptr;
}

/* ========================================================================== */
/*  DEVICE INITIALIZATION                                                     */
/* ========================================================================== */

int mavlinkGenInitAllDevices() {
    int result = 0;

{% if servo_count > 0 %}
    /* Initialize servos */
    for (int i = 0; i < MAVLINK_GEN_SERVO_COUNT; i++) {
        const ServoConfig* cfg = &servoConfigs[i];

        servos[i].attach(cfg->pin, cfg->min_pulse_us, cfg->max_pulse_us);

        /* Set to neutral position */
        int neutralPulse = map(cfg->neutral_angle * 100,
                               cfg->min_angle * 100,
                               cfg->max_angle * 100,
                               cfg->min_pulse_us,
                               cfg->max_pulse_us);
        servos[i].writeMicroseconds(neutralPulse);
    }
{% endif %}

{% if dc_motor_count > 0 %}
    /* Initialize DC motors */
    for (int i = 0; i < MAVLINK_GEN_DC_MOTOR_COUNT; i++) {
        const DCMotorConfig* cfg = &dcMotorConfigs[i];

        pinMode(cfg->pwm_pin, OUTPUT);
        pinMode(cfg->dir_pin1, OUTPUT);
        pinMode(cfg->dir_pin2, OUTPUT);

        /* Stop motor */
        analogWrite(cfg->pwm_pin, 0);
        digitalWrite(cfg->dir_pin1, LOW);
        digitalWrite(cfg->dir_pin2, LOW);
    }
{% endif %}

{% if bldc_motor_count > 0 %}
    /* Initialize BLDC ESCs */
    for (int i = 0; i < MAVLINK_GEN_BLDC_MOTOR_COUNT; i++) {
        const BLDCMotorConfig* cfg = &bldcMotorConfigs[i];

        bldcESCs[i].attach(cfg->esc_pin, cfg->min_throttle_us, cfg->max_throttle_us);

        /* Set to minimum throttle (stopped) */
        bldcESCs[i].writeMicroseconds(cfg->min_throttle_us);
    }

    /* Wait for ESC initialization */
    delay(2000);
{% endif %}

    return result;
}

/* ========================================================================== */
/*  DEVICE UPDATE                                                             */
/* ========================================================================== */

int mavlinkGenUpdateAllDevices() {
    /* Arduino servo library handles updates automatically */
    /* Add custom update logic here if needed */

    return 0;
}

/* ========================================================================== */
/*  EMERGENCY STOP                                                            */
/* ========================================================================== */

void mavlinkGenEmergencyStopAll() {
{% if servo_count > 0 %}
    /* Stop servos (move to neutral) */
    for (int i = 0; i < MAVLINK_GEN_SERVO_COUNT; i++) {
        const ServoConfig* cfg = &servoConfigs[i];

        int neutralPulse = map(cfg->neutral_angle * 100,
                               cfg->min_angle * 100,
                               cfg->max_angle * 100,
                               cfg->min_pulse_us,
                               cfg->max_pulse_us);
        servos[i].writeMicroseconds(neutralPulse);
    }
{% endif %}

{% if dc_motor_count > 0 %}
    /* Stop DC motors */
    for (int i = 0; i < MAVLINK_GEN_DC_MOTOR_COUNT; i++) {
        const DCMotorConfig* cfg = &dcMotorConfigs[i];

        analogWrite(cfg->pwm_pin, 0);
        digitalWrite(cfg->dir_pin1, LOW);
        digitalWrite(cfg->dir_pin2, LOW);
    }
{% endif %}

{% if bldc_motor_count > 0 %}
    /* Stop BLDC motors */
    for (int i = 0; i < MAVLINK_GEN_BLDC_MOTOR_COUNT; i++) {
        const BLDCMotorConfig* cfg = &bldcMotorConfigs[i];

        bldcESCs[i].writeMicroseconds(cfg->min_throttle_us);
    }
{% endif %}
}

/* ========================================================================== */
/*  DEVICE CONTROL FUNCTIONS                                                  */
/* ========================================================================== */

{% if servo_count > 0 %}
/**
 * @brief Set servo angle
 * @param servoIndex Servo index (0 to MAVLINK_GEN_SERVO_COUNT-1)
 * @param angle Angle in degrees
 */
void setServoAngle(int servoIndex, float angle) {
    if (servoIndex < 0 || servoIndex >= MAVLINK_GEN_SERVO_COUNT) return;

    const ServoConfig* cfg = &servoConfigs[servoIndex];

    /* Clamp angle to limits */
    if (angle < cfg->min_angle) angle = cfg->min_angle;
    if (angle > cfg->max_angle) angle = cfg->max_angle;

    /* Convert angle to microseconds */
    int pulse = map(angle * 100,
                    cfg->min_angle * 100,
                    cfg->max_angle * 100,
                    cfg->min_pulse_us,
                    cfg->max_pulse_us);

    servos[servoIndex].writeMicroseconds(pulse);
}
{% endif %}

{% if dc_motor_count > 0 %}
/**
 * @brief Set DC motor speed
 * @param motorIndex Motor index (0 to MAVLINK_GEN_DC_MOTOR_COUNT-1)
 * @param speed Speed (-1.0 to +1.0, negative = reverse)
 */
void setDCMotorSpeed(int motorIndex, float speed) {
    if (motorIndex < 0 || motorIndex >= MAVLINK_GEN_DC_MOTOR_COUNT) return;

    const DCMotorConfig* cfg = &dcMotorConfigs[motorIndex];

    /* Clamp speed */
    if (speed < -1.0f) speed = -1.0f;
    if (speed > 1.0f) speed = 1.0f;

    /* Set direction */
    if (speed >= 0) {
        digitalWrite(cfg->dir_pin1, HIGH);
        digitalWrite(cfg->dir_pin2, LOW);
    } else {
        digitalWrite(cfg->dir_pin1, LOW);
        digitalWrite(cfg->dir_pin2, HIGH);
        speed = -speed;
    }

    /* Set PWM */
    int pwmValue = (int)(speed * 255);
    analogWrite(cfg->pwm_pin, pwmValue);
}
{% endif %}

{% if bldc_motor_count > 0 %}
/**
 * @brief Set BLDC motor throttle
 * @param motorIndex Motor index (0 to MAVLINK_GEN_BLDC_MOTOR_COUNT-1)
 * @param throttle Throttle (0.0 to 1.0)
 */
void setBLDCMotorThrottle(int motorIndex, float throttle) {
    if (motorIndex < 0 || motorIndex >= MAVLINK_GEN_BLDC_MOTOR_COUNT) return;

    const BLDCMotorConfig* cfg = &bldcMotorConfigs[motorIndex];

    /* Clamp throttle */
    if (throttle < 0.0f) throttle = 0.0f;
    if (throttle > 1.0f) throttle = 1.0f;

    /* Convert to microseconds */
    int pulse = cfg->min_throttle_us + (int)(throttle * (cfg->max_throttle_us - cfg->min_throttle_us));

    bldcESCs[motorIndex].writeMicroseconds(pulse);
}
{% endif %}
