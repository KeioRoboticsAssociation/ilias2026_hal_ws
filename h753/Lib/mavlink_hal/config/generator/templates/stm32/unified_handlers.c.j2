/**
 * @file mavlink_unified_handlers.c
 * @brief MAVLink message handlers (auto-generated)
 *
 * This file was automatically generated by MAVLink HAL Code Generator
 * from configuration: {{ config_file }}
 *
 * Generated: {{ generation_timestamp }}
 * Generator Version: {{ generator_version }}
 * Platform: {{ platform.type }}
 * MCU: {{ platform.mcu.model }}
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * Changes will be lost when regenerating from configuration
 */

#include "mavlink_unified_handlers.h"
#include <string.h>
#include <stdio.h>

/* ========================================================================== */
/*  EXTERNAL VARIABLES                                                        */
/* ========================================================================== */

/* MAVLink communication channel (defined by transport layer) */
extern mavlink_channel_t mavlink_channel;

/* ========================================================================== */
/*  MESSAGE ROUTING                                                           */
/* ========================================================================== */

int mavlink_unified_handle_message(const mavlink_message_t* msg)
{
    if (!msg) return -1;

    switch (msg->msgid) {
        case MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE: {
            mavlink_rc_channels_override_t rc_msg;
            mavlink_msg_rc_channels_override_decode(msg, &rc_msg);
            mavlink_handle_rc_channels_override(&rc_msg);
            break;
        }

        case MAVLINK_MSG_ID_MANUAL_CONTROL: {
            mavlink_manual_control_t manual_msg;
            mavlink_msg_manual_control_decode(msg, &manual_msg);
            mavlink_handle_manual_control(&manual_msg);
            break;
        }

{% if has_motor_devices %}
        case MAVLINK_MSG_ID_MOTOR_COMMAND: {
            mavlink_motor_command_t motor_msg;
            mavlink_msg_motor_command_decode(msg, &motor_msg);
            mavlink_handle_motor_command(&motor_msg);
            break;
        }
{% endif %}

        case MAVLINK_MSG_ID_PARAM_REQUEST_LIST: {
            mavlink_param_request_list_t param_list_msg;
            mavlink_msg_param_request_list_decode(msg, &param_list_msg);
            mavlink_handle_param_request_list(&param_list_msg);
            break;
        }

        case MAVLINK_MSG_ID_PARAM_REQUEST_READ: {
            mavlink_param_request_read_t param_read_msg;
            mavlink_msg_param_request_read_decode(msg, &param_read_msg);
            mavlink_handle_param_request_read(&param_read_msg);
            break;
        }

        case MAVLINK_MSG_ID_PARAM_SET: {
            mavlink_param_set_t param_set_msg;
            mavlink_msg_param_set_decode(msg, &param_set_msg);
            mavlink_handle_param_set(&param_set_msg);
            break;
        }

        default:
            /* Unknown message, ignore */
            return -1;
    }

    return 0;
}

/* ========================================================================== */
/*  RC CHANNELS OVERRIDE HANDLER                                              */
/* ========================================================================== */

void mavlink_handle_rc_channels_override(const mavlink_rc_channels_override_t* msg)
{
    if (!msg) return;

    /* Map RC channels 1-8 to device IDs 1-8 */
    uint16_t channels[8] = {
        msg->chan1_raw,
        msg->chan2_raw,
        msg->chan3_raw,
        msg->chan4_raw,
        msg->chan5_raw,
        msg->chan6_raw,
        msg->chan7_raw,
        msg->chan8_raw,
    };

    /* Route to devices (only for RC-controllable devices) */
{% for device in devices %}
{% if device.id <= 8 and device.type in ['servo', 'dc_motor', 'bldc_motor'] %}
    /* Device {{ device.id }}: {{ device.name }} ({{ device.type }}) */
    {
        mavlink_device_t* device = unified_devices_get({{ device.id }});
        if (device && channels[{{ device.id - 1 }}] != UINT16_MAX) {
            /* Map PWM 1000-2000 to device-specific range */
            float pwm = (float)channels[{{ device.id - 1 }}];
{% if device.type == 'servo' %}
            /* Servo: map to angle */
            float min_angle = {{ device.limits.min_value | default(-90.0) }}f;
            float max_angle = {{ device.limits.max_value | default(90.0) }}f;
            float normalized = (pwm - 1000.0f) / 1000.0f;  /* 0.0 to 1.0 */
            float target_angle = min_angle + normalized * (max_angle - min_angle);

            mavlink_device_command_t cmd = {
                .type = MAVLINK_DEVICE_TYPE_SERVO,
                .mode = MAVLINK_CONTROL_MODE_POSITION,
                .data.position = {.target = target_angle},
            };
            mavlink_device_send_command(device, &cmd);
{% elif device.type in ['dc_motor', 'bldc_motor'] %}
            /* Motor: map to duty cycle */
            float duty = (pwm - 1500.0f) / 500.0f;  /* -1.0 to 1.0 */
            if (duty > 1.0f) duty = 1.0f;
            if (duty < -1.0f) duty = -1.0f;

            mavlink_device_command_t cmd = {
                .type = MAVLINK_DEVICE_TYPE_{% if device.type == 'dc_motor' %}DC_MOTOR{% else %}BLDC_MOTOR{% endif %},
                .mode = MAVLINK_CONTROL_MODE_DUTY_CYCLE,
                .data.duty_cycle = {.duty = duty},
            };
            mavlink_device_send_command(device, &cmd);
{% endif %}
        }
    }
{% endif %}
{% endfor %}
}

/* ========================================================================== */
/*  MANUAL CONTROL HANDLER                                                    */
/* ========================================================================== */

void mavlink_handle_manual_control(const mavlink_manual_control_t* msg)
{
    if (!msg) return;

    /* Joystick axes: x, y, z, r (range: -1000 to 1000) */
    /* Map to specific devices based on configuration */

    /* Example: Map joystick to motor velocities */
    /* This is a placeholder - customize based on robot configuration */
}

/* ========================================================================== */
/*  MOTOR COMMAND HANDLER                                                     */
/* ========================================================================== */

{% if has_motor_devices %}
void mavlink_handle_motor_command(const mavlink_motor_command_t* msg)
{
    if (!msg) return;

    /* Find device by ID */
    mavlink_device_t* device = unified_devices_get(msg->motor_id);
    if (!device) return;

    /* Enable/disable device */
    if (msg->enable) {
        mavlink_device_enable(device, true);
    } else {
        mavlink_device_enable(device, false);
        return;
    }

    /* Send command based on control mode */
    mavlink_device_command_t cmd = {0};

    switch (msg->control_mode) {
        case 0:  /* Position */
            cmd.mode = MAVLINK_CONTROL_MODE_POSITION;
            cmd.data.position.target = msg->target_value;
            break;

        case 1:  /* Velocity */
            cmd.mode = MAVLINK_CONTROL_MODE_VELOCITY;
            cmd.data.velocity.target = msg->target_value;
            break;

        case 2:  /* Current */
            cmd.mode = MAVLINK_CONTROL_MODE_CURRENT;
            cmd.data.current.target = msg->target_value;
            break;

        case 3:  /* Duty cycle */
            cmd.mode = MAVLINK_CONTROL_MODE_DUTY_CYCLE;
            cmd.data.duty_cycle.duty = msg->target_value;
            break;

        default:
            return;
    }

    /* Get device type and set command type */
    cmd.type = device->id.type;

    /* Send command */
    mavlink_device_send_command(device, &cmd);
}
{% endif %}

/* ========================================================================== */
/*  PARAMETER HANDLERS                                                        */
/* ========================================================================== */

/**
 * @brief Get parameter name for device
 *
 * Generates parameter name in format: TYPE_ID_PARAM
 * Examples: "SERVO_1_MIN_PULSE", "RM_20_SPD_KP"
 */
static void get_param_name(uint8_t device_id, mavlink_device_type_t type,
                           const char* param_suffix, char* out_name, size_t max_len)
{
    const char* type_prefix = "";

    switch (type) {
        case MAVLINK_DEVICE_TYPE_SERVO:         type_prefix = "SERVO"; break;
        case MAVLINK_DEVICE_TYPE_DC_MOTOR:      type_prefix = "DC"; break;
        case MAVLINK_DEVICE_TYPE_BLDC_MOTOR:    type_prefix = "BLDC"; break;
        case MAVLINK_DEVICE_TYPE_ROBOMASTER:    type_prefix = "RM"; break;
        case MAVLINK_DEVICE_TYPE_RS485_MOTOR:   type_prefix = "RS485"; break;
        default:                                 type_prefix = "DEV"; break;
    }

    snprintf(out_name, max_len, "%s_%d_%s", type_prefix, device_id, param_suffix);
}

void mavlink_handle_param_request_list(const mavlink_param_request_list_t* msg)
{
    if (!msg) return;

    /* Get all devices */
    uint32_t device_count = unified_devices_count();
    uint16_t param_index = 0;
    uint16_t total_params = 0;

    /* Count total parameters (estimate: ~5 params per motor device) */
{% for device in devices %}
{% if device.type in ['dc_motor', 'bldc_motor', 'robomaster'] %}
    total_params += 6;  /* Device {{ device.id }}: {{ device.name }} */
{% elif device.type == 'servo' %}
    total_params += 3;  /* Device {{ device.id }}: {{ device.name }} */
{% endif %}
{% endfor %}

    /* Send parameters for each device */
{% for device in devices %}
{% if device.type in ['dc_motor', 'bldc_motor'] %}
    /* Device {{ device.id }}: {{ device.name }} (DC Motor) */
    {
        mavlink_device_t* dev = unified_devices_get({{ device.id }});
        if (dev) {
            char param_name[16];
            float param_value;

            /* Position PID */
            if (mavlink_device_get_param(dev, "pos_kp", &param_value) == MAVLINK_DEVICE_ERROR_NONE) {
                get_param_name({{ device.id }}, dev->id.type, "POS_KP", param_name, sizeof(param_name));
                mavlink_send_param_value(param_name, param_value, param_index++, total_params);
            }
            if (mavlink_device_get_param(dev, "pos_ki", &param_value) == MAVLINK_DEVICE_ERROR_NONE) {
                get_param_name({{ device.id }}, dev->id.type, "POS_KI", param_name, sizeof(param_name));
                mavlink_send_param_value(param_name, param_value, param_index++, total_params);
            }
            if (mavlink_device_get_param(dev, "pos_kd", &param_value) == MAVLINK_DEVICE_ERROR_NONE) {
                get_param_name({{ device.id }}, dev->id.type, "POS_KD", param_name, sizeof(param_name));
                mavlink_send_param_value(param_name, param_value, param_index++, total_params);
            }

            /* Velocity PID */
            if (mavlink_device_get_param(dev, "vel_kp", &param_value) == MAVLINK_DEVICE_ERROR_NONE) {
                get_param_name({{ device.id }}, dev->id.type, "VEL_KP", param_name, sizeof(param_name));
                mavlink_send_param_value(param_name, param_value, param_index++, total_params);
            }
            if (mavlink_device_get_param(dev, "vel_ki", &param_value) == MAVLINK_DEVICE_ERROR_NONE) {
                get_param_name({{ device.id }}, dev->id.type, "VEL_KI", param_name, sizeof(param_name));
                mavlink_send_param_value(param_name, param_value, param_index++, total_params);
            }
            if (mavlink_device_get_param(dev, "vel_kd", &param_value) == MAVLINK_DEVICE_ERROR_NONE) {
                get_param_name({{ device.id }}, dev->id.type, "VEL_KD", param_name, sizeof(param_name));
                mavlink_send_param_value(param_name, param_value, param_index++, total_params);
            }
        }
    }
{% elif device.type == 'robomaster' %}
    /* Device {{ device.id }}: {{ device.name }} (RoboMaster) */
    {
        mavlink_device_t* dev = unified_devices_get({{ device.id }});
        if (dev) {
            char param_name[16];
            float param_value;

            /* Speed PID */
            if (mavlink_device_get_param(dev, "speed_kp", &param_value) == MAVLINK_DEVICE_ERROR_NONE) {
                get_param_name({{ device.id }}, dev->id.type, "SPD_KP", param_name, sizeof(param_name));
                mavlink_send_param_value(param_name, param_value, param_index++, total_params);
            }
            if (mavlink_device_get_param(dev, "speed_ki", &param_value) == MAVLINK_DEVICE_ERROR_NONE) {
                get_param_name({{ device.id }}, dev->id.type, "SPD_KI", param_name, sizeof(param_name));
                mavlink_send_param_value(param_name, param_value, param_index++, total_params);
            }
            if (mavlink_device_get_param(dev, "speed_kd", &param_value) == MAVLINK_DEVICE_ERROR_NONE) {
                get_param_name({{ device.id }}, dev->id.type, "SPD_KD", param_name, sizeof(param_name));
                mavlink_send_param_value(param_name, param_value, param_index++, total_params);
            }

            /* Angle PID */
            if (mavlink_device_get_param(dev, "angle_kp", &param_value) == MAVLINK_DEVICE_ERROR_NONE) {
                get_param_name({{ device.id }}, dev->id.type, "ANG_KP", param_name, sizeof(param_name));
                mavlink_send_param_value(param_name, param_value, param_index++, total_params);
            }
            if (mavlink_device_get_param(dev, "angle_ki", &param_value) == MAVLINK_DEVICE_ERROR_NONE) {
                get_param_name({{ device.id }}, dev->id.type, "ANG_KI", param_name, sizeof(param_name));
                mavlink_send_param_value(param_name, param_value, param_index++, total_params);
            }
            if (mavlink_device_get_param(dev, "angle_kd", &param_value) == MAVLINK_DEVICE_ERROR_NONE) {
                get_param_name({{ device.id }}, dev->id.type, "ANG_KD", param_name, sizeof(param_name));
                mavlink_send_param_value(param_name, param_value, param_index++, total_params);
            }
        }
    }
{% endif %}
{% endfor %}
}

void mavlink_handle_param_request_read(const mavlink_param_request_read_t* msg)
{
    if (!msg) return;

    /* Parse parameter name: TYPE_ID_PARAM */
    char param_name[16];
    strncpy(param_name, msg->param_id, sizeof(param_name) - 1);
    param_name[sizeof(param_name) - 1] = '\0';

    /* Extract device ID and parameter name */
    /* Example: "RM_20_SPD_KP" -> device_id=20, param="speed_kp" */
    /* This is a simplified implementation */

    /* TODO: Parse parameter name and route to device */
}

void mavlink_handle_param_set(const mavlink_param_set_t* msg)
{
    if (!msg) return;

    /* Parse parameter name and route to device */
    char param_name[16];
    strncpy(param_name, msg->param_id, sizeof(param_name) - 1);
    param_name[sizeof(param_name) - 1] = '\0';

    /* TODO: Parse parameter name, find device, set parameter */

    /* Echo back parameter value */
    mavlink_send_param_value(param_name, msg->param_value, msg->param_index, 0);
}

/* ========================================================================== */
/*  TELEMETRY FUNCTIONS                                                       */
/* ========================================================================== */

void mavlink_send_heartbeat(void)
{
    mavlink_message_t msg;
    mavlink_msg_heartbeat_pack(
        MAVLINK_SYSTEM_ID,
        MAVLINK_COMPONENT_ID,
        &msg,
        MAV_TYPE_GENERIC,
        MAV_AUTOPILOT_INVALID,
        MAV_MODE_MANUAL_ARMED,
        0,  /* custom_mode */
        MAV_STATE_ACTIVE
    );

    /* Send via transport layer (implementation specific) */
    /* mavlink_send_message(&msg); */
}

void mavlink_send_device_telemetry(void)
{
    /* Get telemetry for all devices */
{% for device in devices %}
    /* Device {{ device.id }}: {{ device.name }} */
    {
        mavlink_device_t* dev = unified_devices_get({{ device.id }});
        if (dev && dev->status.enabled) {
            mavlink_device_feedback_t feedback;
            if (mavlink_device_get_feedback(dev, &feedback) == MAVLINK_DEVICE_ERROR_NONE) {
{% if device.type in ['servo', 'dc_motor', 'bldc_motor', 'robomaster', 'rs485_motor'] %}
                /* Send motor status */
                /* TODO: Send custom MAVLink message with feedback data */
{% elif device.type == 'encoder' %}
                /* Send sensor data */
                /* TODO: Send custom MAVLink message with sensor data */
{% endif %}
            }
        }
    }
{% endfor %}
}

void mavlink_send_param_value(const char* param_id, float param_value,
                                uint16_t param_index, uint16_t param_count)
{
    mavlink_message_t msg;
    mavlink_msg_param_value_pack(
        MAVLINK_SYSTEM_ID,
        MAVLINK_COMPONENT_ID,
        &msg,
        param_id,
        param_value,
        MAV_PARAM_TYPE_REAL32,
        param_count,
        param_index
    );

    /* Send via transport layer (implementation specific) */
    /* mavlink_send_message(&msg); */
}
