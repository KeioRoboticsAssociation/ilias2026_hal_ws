/**
 * @file mavlink_generated_handlers.c
 * @brief Auto-generated MAVLink message handlers
 *
 * Generated from: {{ config_file }}
 * Platform: {{ platform.type | upper }}
 * Generated: {{ generated_timestamp }}
 * Generator Version: {{ generator_version }}
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 * Any changes will be overwritten on next generation.
 */

#include "mavlink_generated_config.h"
#include "mavlink_generated_params.h"

/* Include MAVLink library (robomaster_motor dialect includes common) */
#include "robomaster_motor/mavlink.h"

/* Include motor controllers */
{% if servo_count > 0 %}
#include "motors/servo_controller.h"
{% endif %}
{% if dc_motor_count > 0 %}
#include "motors/dc_controller.h"
{% endif %}
{% if robomaster_count > 0 %}
#include "motors/robomaster_controller.h"
{% endif %}
{% if rs485_motor_count > 0 %}
#include "motors/rs485_controller.h"
{% endif %}

#include <string.h>

/* ========================================================================== */
/*  RC_CHANNELS_OVERRIDE HANDLER                                              */
/* ========================================================================== */

/**
 * @brief Handle RC_CHANNELS_OVERRIDE message (ID 70)
 *
 * Map RC channels to device commands based on device ID.
 * Channel values: 0-1000 = disabled, 1000-2000 = control range
 */
void mavlink_gen_handle_rc_channels_override(const mavlink_message_t* msg) {
    mavlink_rc_channels_override_t rc;
    mavlink_msg_rc_channels_override_decode(msg, &rc);

    /* RC channels 1-8 map to motor IDs 1-8 */
    uint16_t channels[8] = {
        rc.chan1_raw, rc.chan2_raw, rc.chan3_raw, rc.chan4_raw,
        rc.chan5_raw, rc.chan6_raw, rc.chan7_raw, rc.chan8_raw
    };

    for (int i = 0; i < 8; i++) {
        uint16_t pwm = channels[i];
        uint8_t motor_id = i + 1;  /* Motor IDs 1-8 */

        /* Skip disabled channels */
        if (pwm == 0 || pwm == UINT16_MAX) {
            continue;
        }

        /* Get controller using unified interface */
        motor_controller_t* controller = mavlink_gen_get_controller_by_id(motor_id);
        if (!controller || !controller->vtable || !controller->vtable->set_command) {
            continue;
        }

        /* Convert PWM (1000-2000) to normalized value (-1.0 to +1.0) */
        float normalized = (pwm - 1500) / 500.0f;

        /* Clamp to valid range */
        if (normalized > 1.0f) normalized = 1.0f;
        if (normalized < -1.0f) normalized = -1.0f;

        /* Create motor command (duty cycle mode for RC control) */
        motor_command_t cmd = {
            .motor_id = motor_id,
            .enable = true,
            .mode = CONTROL_MODE_DUTY_CYCLE,
            .target_value = normalized,
        };

        /* Send command via vtable */
        controller->vtable->set_command(controller, &cmd);
    }
}

/* ========================================================================== */
/*  MANUAL_CONTROL HANDLER                                                    */
/* ========================================================================== */

/**
 * @brief Handle MANUAL_CONTROL message (ID 69)
 *
 * Manual control with joystick axes (x, y, z, r) and buttons.
 * Values range: -1000 to +1000 for axes
 */
void mavlink_gen_handle_manual_control(const mavlink_message_t* msg) {
    mavlink_manual_control_t manual;
    mavlink_msg_manual_control_decode(msg, &manual);

    /* Axes: x, y, z, r (range: -1000 to +1000) */
    float x_norm = manual.x / 1000.0f;  /* Forward/backward */
    float y_norm = manual.y / 1000.0f;  /* Left/right */
    float z_norm = manual.z / 1000.0f;  /* Throttle */
    float r_norm = manual.r / 1000.0f;  /* Rotation */

    /* Example: Map to drive motors (customize for your robot) */
{% if dc_motor_count >= 2 %}
    /* Differential drive example (IDs 10-11) */
    float left_speed = (z_norm + r_norm) * mavlink_gen_dc_motor_configs[0].max_rpm;
    float right_speed = (z_norm - r_norm) * mavlink_gen_dc_motor_configs[1].max_rpm;

    /* Set motor speeds (implementation-specific) */
    /* dc_motor_controller_set_speed(dc_motor_controllers[0], left_speed); */
    /* dc_motor_controller_set_speed(dc_motor_controllers[1], right_speed); */
{% endif %}

    /* Buttons can trigger special functions */
    /* uint16_t buttons = manual.buttons; */
}

/* ========================================================================== */
/*  MOTOR_COMMAND HANDLER (Custom Message ID 12004)                           */
/* ========================================================================== */

/**
 * @brief Handle MOTOR_COMMAND message (ID 12004)
 *
 * Generic motor control for all motor types (IDs 1-255).
 * Control modes: 0=position, 1=velocity, 2=current, 3=duty_cycle
 */
void mavlink_gen_handle_motor_command(const mavlink_message_t* msg) {
    /* Decode MOTOR_COMMAND message using MAVLink decode function */
    mavlink_motor_command_t motor_cmd_msg;
    mavlink_msg_motor_command_decode(msg, &motor_cmd_msg);

    /* Get controller using unified interface */
    motor_controller_t* controller = mavlink_gen_get_controller_by_id(motor_cmd_msg.motor_id);
    if (!controller || !controller->vtable || !controller->vtable->set_command) {
        return;  /* Motor not found or invalid */
    }

    /* Create motor command */
    motor_command_t cmd = {
        .motor_id = motor_cmd_msg.motor_id,
        .enable = motor_cmd_msg.enable ? true : false,
        .mode = (control_mode_t)motor_cmd_msg.control_mode,
        .target_value = motor_cmd_msg.target_value,
    };

    /* Send command via vtable */
    controller->vtable->set_command(controller, &cmd);
}

/* ========================================================================== */
/*  PARAMETER REQUEST LIST HANDLER                                            */
/* ========================================================================== */

/**
 * @brief Handle PARAM_REQUEST_LIST message (ID 21)
 *
 * Send all parameter values to ground station
 */
void mavlink_gen_handle_param_request_list(const mavlink_message_t* msg,
                                           mavlink_channel_t chan) {
    /* Send all parameters defined in mavlink_generated_params.h */
    for (int i = 0; i < MAVLINK_GEN_PARAM_COUNT; i++) {
        const mavlink_gen_param_def_t* param = &mavlink_gen_param_defs[i];

        mavlink_message_t response;
        mavlink_msg_param_value_pack(
            MAVLINK_GEN_SYSTEM_ID,
            MAVLINK_GEN_COMPONENT_ID,
            &response,
            param->name,
            param->current_value,
            MAV_PARAM_TYPE_REAL32,
            MAVLINK_GEN_PARAM_COUNT,
            i
        );

        /* Send message (implementation-specific) */
        /* mavlink_send_message(chan, &response); */
    }
}

/* ========================================================================== */
/*  PARAMETER REQUEST READ HANDLER                                            */
/* ========================================================================== */

/**
 * @brief Handle PARAM_REQUEST_READ message (ID 20)
 *
 * Send specific parameter value
 */
void mavlink_gen_handle_param_request_read(const mavlink_message_t* msg,
                                           mavlink_channel_t chan) {
    mavlink_param_request_read_t req;
    mavlink_msg_param_request_read_decode(msg, &req);

    /* Find parameter by name or index */
    const mavlink_gen_param_def_t* param = NULL;

    if (req.param_index >= 0 && req.param_index < MAVLINK_GEN_PARAM_COUNT) {
        param = &mavlink_gen_param_defs[req.param_index];
    } else {
        /* Search by name */
        for (int i = 0; i < MAVLINK_GEN_PARAM_COUNT; i++) {
            if (strncmp(mavlink_gen_param_defs[i].name, req.param_id, 16) == 0) {
                param = &mavlink_gen_param_defs[i];
                break;
            }
        }
    }

    if (param) {
        mavlink_message_t response;
        mavlink_msg_param_value_pack(
            MAVLINK_GEN_SYSTEM_ID,
            MAVLINK_GEN_COMPONENT_ID,
            &response,
            param->name,
            param->current_value,
            MAV_PARAM_TYPE_REAL32,
            MAVLINK_GEN_PARAM_COUNT,
            req.param_index
        );

        /* Send message (implementation-specific) */
        /* mavlink_send_message(chan, &response); */
    }
}

/* ========================================================================== */
/*  PARAMETER SET HANDLER                                                     */
/* ========================================================================== */

/**
 * @brief Handle PARAM_SET message (ID 23)
 *
 * Set parameter value and apply to device
 */
void mavlink_gen_handle_param_set(const mavlink_message_t* msg,
                                  mavlink_channel_t chan) {
    mavlink_param_set_t set;
    mavlink_msg_param_set_decode(msg, &set);

    /* Find parameter */
    mavlink_gen_param_def_t* param = NULL;
    int param_index = -1;

    for (int i = 0; i < MAVLINK_GEN_PARAM_COUNT; i++) {
        if (strncmp(mavlink_gen_param_defs[i].name, set.param_id, 16) == 0) {
            param = &mavlink_gen_param_defs[i];
            param_index = i;
            break;
        }
    }

    if (param) {
        /* Validate range */
        if (set.param_value >= param->min_value && set.param_value <= param->max_value) {
            /* Update value */
            param->current_value = set.param_value;

            /* Apply to device (implementation-specific) */
            /* mavlink_gen_apply_parameter(param); */

            /* Send confirmation */
            mavlink_message_t response;
            mavlink_msg_param_value_pack(
                MAVLINK_GEN_SYSTEM_ID,
                MAVLINK_GEN_COMPONENT_ID,
                &response,
                param->name,
                param->current_value,
                MAV_PARAM_TYPE_REAL32,
                MAVLINK_GEN_PARAM_COUNT,
                param_index
            );

            /* Send message (implementation-specific) */
            /* mavlink_send_message(chan, &response); */
        }
    }
}

/* ========================================================================== */
/*  MAIN MESSAGE DISPATCHER                                                   */
/* ========================================================================== */

/**
 * @brief Dispatch MAVLink message to appropriate handler
 *
 * Call this function when a MAVLink message is received
 */
void mavlink_gen_handle_message(const mavlink_message_t* msg,
                                mavlink_channel_t chan) {
    switch (msg->msgid) {
        case MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE:
            mavlink_gen_handle_rc_channels_override(msg);
            break;

        case MAVLINK_MSG_ID_MANUAL_CONTROL:
            mavlink_gen_handle_manual_control(msg);
            break;

        case 12004:  /* MOTOR_COMMAND (custom message) */
            mavlink_gen_handle_motor_command(msg);
            break;

        case MAVLINK_MSG_ID_PARAM_REQUEST_LIST:
            mavlink_gen_handle_param_request_list(msg, chan);
            break;

        case MAVLINK_MSG_ID_PARAM_REQUEST_READ:
            mavlink_gen_handle_param_request_read(msg, chan);
            break;

        case MAVLINK_MSG_ID_PARAM_SET:
            mavlink_gen_handle_param_set(msg, chan);
            break;

        default:
            /* Unhandled message */
            break;
    }
}
