/**
 * @file mavlink_generated_devices.c
 * @brief Auto-generated device initialization and management
 *
 * Generated from: {{ config_file }}
 * Platform: {{ platform.type | upper }}
 * Generated: {{ generated_timestamp }}
 * Generator Version: {{ generator_version }}
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 * Any changes will be overwritten on next generation.
 */

#include "mavlink_generated_config.h"

/* Include parameter implementation in this compilation unit */
#define MAVLINK_GENERATED_PARAMS_IMPLEMENTATION
#include "mavlink_generated_params.h"

/* Include platform-specific headers */
#ifdef STM32H7xx
#include "stm32h7xx_hal.h"
#elif defined(STM32F4xx)
#include "stm32f4xx_hal.h"
#elif defined(STM32F7xx)
#include "stm32f7xx_hal.h"
#endif

/* Include motor controllers */
{% if servo_count > 0 %}
#include "motors/servo_controller.h"
{% endif %}
{% if dc_motor_count > 0 %}
#include "motors/dc_controller.h"
{% endif %}
{% if robomaster_count > 0 %}
#include "motors/robomaster_controller.h"
{% endif %}
{% if rs485_motor_count > 0 %}
#include "motors/rs485_controller.h"
{% endif %}

/* Include hardware manager */
#include "hal/hardware_manager.h"

/* ========================================================================== */
/*  SERVO CONFIGURATION DATA                                                  */
/* ========================================================================== */

{% if servo_count > 0 %}
const mavlink_gen_servo_config_t mavlink_gen_servo_configs[MAVLINK_GEN_SERVO_COUNT] = {
{% for device in devices_by_type.servo %}
    {
        .id = {{ device.id }},
        .name = "{{ device.name }}",
        .timer_id = {{ device.hardware.timer }},
        .channel = TIM_CHANNEL_{{ device.hardware.channel }},
        .min_pulse_us = {{ device.config.servo.min_pulse_us | default(1000) }},
        .max_pulse_us = {{ device.config.servo.max_pulse_us | default(2000) }},
{% if device.limits %}
        .min_angle = {{ device.limits.min_value | default(-90.0) | format_float }},
        .max_angle = {{ device.limits.max_value | default(90.0) | format_float }},
{% else %}
        .min_angle = -90.0f,
        .max_angle = 90.0f,
{% endif %}
        .neutral_angle = {{ device.config.servo.neutral_angle | default(0.0) | format_float }},
    },
{% endfor %}
};

/* Servo controller storage */
static motor_controller_t servo_controllers_storage[MAVLINK_GEN_SERVO_COUNT];
static servo_private_t servo_private_data[MAVLINK_GEN_SERVO_COUNT];
static motor_controller_t* servo_controllers[MAVLINK_GEN_SERVO_COUNT];
{% endif %}

/* ========================================================================== */
/*  DC MOTOR CONFIGURATION DATA                                               */
/* ========================================================================== */

{% if dc_motor_count > 0 %}
const mavlink_gen_dc_motor_config_t mavlink_gen_dc_motor_configs[MAVLINK_GEN_DC_MOTOR_COUNT] = {
{% for device in devices_by_type.dc_motor %}
    {
        .id = {{ device.id }},
        .name = "{{ device.name }}",
        .timer_id = {{ device.hardware.timer }},
        .channel = TIM_CHANNEL_{{ device.hardware.channel }},
{% if device.hardware.pins and device.hardware.pins.dir %}
        .dir_pin = "{{ device.hardware.pins.dir }}",
{% else %}
        .dir_pin = NULL,
{% endif %}
{% if device.limits and device.limits.max_speed %}
        .max_rpm = {{ device.limits.max_speed | format_float }},
{% else %}
        .max_rpm = 1000.0f,
{% endif %}
        .has_encoder = {{ 'true' if device.config.dc_motor.encoder else 'false' }},
{% if device.config.dc_motor.encoder %}
        .encoder_ppr = {{ device.config.dc_motor.encoder.ppr | default(1024) }},
{% else %}
        .encoder_ppr = 0,
{% endif %}
{% if device.config.dc_motor.direction_inverted %}
        .direction_inverted = {{ 'true' if device.config.dc_motor.direction_inverted else 'false' }},
{% else %}
        .direction_inverted = false,
{% endif %}
    },
{% endfor %}
};

/* DC motor controller storage */
static motor_controller_t dc_motor_controllers_storage[MAVLINK_GEN_DC_MOTOR_COUNT];
static dc_motor_private_t dc_motor_private_data[MAVLINK_GEN_DC_MOTOR_COUNT];
static motor_controller_t* dc_motor_controllers[MAVLINK_GEN_DC_MOTOR_COUNT];
{% endif %}

/* ========================================================================== */
/*  ROBOMASTER MOTOR CONFIGURATION DATA                                       */
/* ========================================================================== */

{% if robomaster_count > 0 %}
const mavlink_gen_robomaster_config_t mavlink_gen_robomaster_configs[MAVLINK_GEN_ROBOMASTER_COUNT] = {
{% for device in devices_by_type.robomaster %}
    {
        .id = {{ device.id }},
        .name = "{{ device.name }}",
        .can_id = {{ device.hardware.can_id | to_hex }},
        .motor_type = ROBOMASTER_MOTOR_TYPE_{{ device.config.robomaster.motor_type | to_upper }},
{% if device.limits and device.limits.max_speed %}
        .max_rpm = {{ device.limits.max_speed | format_float }},
{% else %}
        .max_rpm = 10000.0f,
{% endif %}
{% if device.limits and device.limits.max_current_ma %}
        .max_current = {{ device.limits.max_current_ma }} / 1000.0f,
{% else %}
        .max_current = 10.0f,
{% endif %}
    },
{% endfor %}
};

/* RoboMaster controller storage */
static motor_controller_t robomaster_controllers_storage[MAVLINK_GEN_ROBOMASTER_COUNT];
static robomaster_private_t robomaster_private_data[MAVLINK_GEN_ROBOMASTER_COUNT];
static motor_controller_t* robomaster_controllers[MAVLINK_GEN_ROBOMASTER_COUNT];
{% endif %}

/* ========================================================================== */
/*  RS485 MOTOR CONFIGURATION DATA                                            */
/* ========================================================================== */

{% if rs485_motor_count > 0 %}
const mavlink_gen_rs485_config_t mavlink_gen_rs485_configs[MAVLINK_GEN_RS485_MOTOR_COUNT] = {
{% for device in devices_by_type.rs485_motor %}
    {
        .id = {{ device.id }},
        .name = "{{ device.name }}",
        .uart_port = {{ device.hardware.uart | uart_to_number }},
        .rs485_device_id = {{ device.config.rs485_motor.device_id }},
        .motor_index = {{ device.config.rs485_motor.motor_index | default(0) }},
        .control_mode = RS485_MODE_{{ device.config.rs485_motor.control_mode | to_upper }},
{% if device.limits and device.limits.max_speed %}
        .max_rps = {{ device.limits.max_speed | format_float }},
{% else %}
        .max_rps = 100.0f,
{% endif %}
    },
{% endfor %}
};

/* RS485 controller storage */
static motor_controller_t rs485_controllers_storage[MAVLINK_GEN_RS485_MOTOR_COUNT];
static rs485_private_t rs485_private_data[MAVLINK_GEN_RS485_MOTOR_COUNT];
static motor_controller_t* rs485_controllers[MAVLINK_GEN_RS485_MOTOR_COUNT];
{% endif %}

/* ========================================================================== */
/*  IMU SENSOR CONFIGURATION DATA                                             */
/* ========================================================================== */

{% if imu_count > 0 %}
const mavlink_gen_imu_config_t mavlink_gen_imu_configs[MAVLINK_GEN_IMU_COUNT] = {
{% for device in devices_by_type.imu %}
    {
        .id = {{ device.id }},
        .name = "{{ device.name }}",
        .sensor_type = "{{ device.config.imu.sensor_type }}",
        .i2c_address = {{ device.hardware.i2c_address | to_hex }},
        .sample_rate_hz = {{ device.config.imu.sample_rate_hz | default(100) }},
    },
{% endfor %}
};
{% endif %}

/* ========================================================================== */
/*  GPS MODULE CONFIGURATION DATA                                             */
/* ========================================================================== */

{% if gps_count > 0 %}
const mavlink_gen_gps_config_t mavlink_gen_gps_configs[MAVLINK_GEN_GPS_COUNT] = {
{% for device in devices_by_type.gps %}
    {
        .id = {{ device.id }},
        .name = "{{ device.name }}",
        .module_type = "{{ device.config.gps.module_type }}",
        .uart_port = "{{ device.hardware.uart_port }}",
        .baudrate = {{ device.config.gps.baudrate | default(9600) }},
    },
{% endfor %}
};
{% endif %}

/* ========================================================================== */
/*  ANALOG SENSOR CONFIGURATION DATA                                          */
/* ========================================================================== */

{% if analog_sensor_count > 0 %}
const mavlink_gen_analog_sensor_config_t mavlink_gen_analog_sensor_configs[MAVLINK_GEN_ANALOG_SENSOR_COUNT] = {
{% for device in devices_by_type.analog_sensor %}
    {
        .id = {{ device.id }},
        .name = "{{ device.name }}",
        .sensor_type = ANALOG_SENSOR_{{ device.config.analog_sensor.sensor_type | to_upper }},
        .adc_channel = "{{ device.hardware.adc_channel }}",
        .scale_factor = {{ device.config.analog_sensor.scale_factor | default(1.0) | format_float }},
        .offset = {{ device.config.analog_sensor.offset | default(0.0) | format_float }},
    },
{% endfor %}
};
{% endif %}

/* ========================================================================== */
/*  DEVICE NAME LOOKUP                                                        */
/* ========================================================================== */

const char* mavlink_gen_get_device_name(uint8_t device_id) {
{% for device in devices %}
    if (device_id == {{ device.id }}) return "{{ device.name }}";
{% endfor %}
    return NULL;
}

/* ========================================================================== */
/*  DEVICE INITIALIZATION                                                     */
/* ========================================================================== */

int mavlink_gen_init_all_devices(void) {
    int result = 0;

{% if servo_count > 0 %}
    /* Initialize servos */
    for (int i = 0; i < MAVLINK_GEN_SERVO_COUNT; i++) {
        const mavlink_gen_servo_config_t* cfg = &mavlink_gen_servo_configs[i];

        servo_config_t servo_cfg = {
            .id = cfg->id,
            .initial_offset = 0.0f,
            .min_angle = cfg->min_angle,
            .max_angle = cfg->max_angle,
            .pulse_min_us = cfg->min_pulse_us,
            .pulse_max_us = cfg->max_pulse_us,
            .pulse_neutral_us = (cfg->min_pulse_us + cfg->max_pulse_us) / 2,
            .direction_inverted = false,
            .max_velocity_deg_per_s = 120.0f,
            .max_acceleration_deg_per_s2 = 240.0f,
            .watchdog_timeout_ms = 1000,
            .startup_angle_deg = cfg->neutral_angle,
            .start_disabled = false,
            .failsafe_behavior = SERVO_FAILSAFE_NEUTRAL,
        };

        error_code_t err = servo_controller_create(
            cfg->id,
            cfg->timer_id,
            cfg->channel,
            &servo_cfg,
            &servo_controllers_storage[i],
            &servo_private_data[i]
        );

        if (err == ERROR_OK) {
            servo_controllers[i] = &servo_controllers_storage[i];
        } else {
            servo_controllers[i] = NULL;
            result = -1;
            /* Continue to initialize other devices */
        }
    }
{% endif %}

{% if dc_motor_count > 0 %}
    /* Initialize DC motors */
    for (int i = 0; i < MAVLINK_GEN_DC_MOTOR_COUNT; i++) {
        const mavlink_gen_dc_motor_config_t* cfg = &mavlink_gen_dc_motor_configs[i];

        dc_motor_config_t dc_cfg = {
            .id = cfg->id,
            // Speed PID gains
            .speed_kp = 0.1f,
            .speed_ki = 0.05f,
            .speed_kd = 0.0f,
            .speed_max_integral = 0.3f,
            .speed_max_output = 1.0f,
            // Position PID gains
            .position_kp = 0.5f,
            .position_ki = 0.0f,
            .position_kd = 0.1f,
            .position_max_integral = 100.0f,
            .position_max_output = 10.0f,
            // Limits
            .max_speed_rad_s = 15.0f,
            .max_acceleration_rad_s2 = 50.0f,
            .position_limit_min_rad = -314.159f,
            .position_limit_max_rad = 314.159f,
            .use_position_limits = true,
            // Control
            .watchdog_timeout_ms = 1000,
            .control_period_ms = 10,
            .direction_inverted = cfg->direction_inverted,
        };

        error_code_t err = dc_motor_controller_create(
            cfg->id,
            cfg->timer_id,
            cfg->channel,
            &dc_cfg,
            &dc_motor_controllers_storage[i],
            &dc_motor_private_data[i]
        );

        if (err == ERROR_OK) {
            dc_motor_controllers[i] = &dc_motor_controllers_storage[i];
        } else {
            dc_motor_controllers[i] = NULL;
            result = -1;
        }
    }
{% endif %}

{% if robomaster_count > 0 %}
    /* Initialize RoboMaster motors */
    for (int i = 0; i < MAVLINK_GEN_ROBOMASTER_COUNT; i++) {
        const mavlink_gen_robomaster_config_t* cfg = &mavlink_gen_robomaster_configs[i];

        robomaster_config_t rm_cfg = {
            .id = cfg->id,
            .can_id = cfg->can_id,
            // Angle PID gains
            .angle_kp = 0.1f,
            .angle_ki = 0.0f,
            .angle_kd = 0.0f,
            // Speed PID gains (tunable via MAVLink params)
            .speed_kp = 50.0f,
            .speed_ki = 0.1f,
            .speed_kd = 0.0f,
            // Limits
            .max_speed_rad_s = 10.0f,
            .max_acceleration_rad_s2 = 30.0f,
            .watchdog_timeout_ms = 500,
        };

        error_code_t err = robomaster_controller_create(
            cfg->id,
            &rm_cfg,
            &robomaster_controllers_storage[i],
            &robomaster_private_data[i]
        );

        if (err == ERROR_OK) {
            robomaster_controllers[i] = &robomaster_controllers_storage[i];
        } else {
            robomaster_controllers[i] = NULL;
            result = -1;
        }
    }
{% endif %}

{% if rs485_motor_count > 0 %}
    /* Initialize RS485 motors */
    for (int i = 0; i < MAVLINK_GEN_RS485_MOTOR_COUNT; i++) {
        const mavlink_gen_rs485_config_t* cfg = &mavlink_gen_rs485_configs[i];

        rs485_config_t rs485_cfg = {
            .id = cfg->id,
            .rs485_device_id = cfg->rs485_device_id,
            .motor_index = cfg->motor_index,
            .uart_id = cfg->uart_port,
            .control_mode = cfg->control_mode,
            .max_rps = cfg->max_rps,
            .max_acceleration_rps2 = 200.0f,
            .max_count = 8192,
            .max_rotation = 100,
            .watchdog_timeout_ms = 1000,
            .retry_count = 3,
        };

        error_code_t err = rs485_controller_create(
            cfg->id,
            &rs485_cfg,
            &rs485_controllers_storage[i],
            &rs485_private_data[i]
        );

        if (err == ERROR_OK) {
            rs485_controllers[i] = &rs485_controllers_storage[i];
        } else {
            rs485_controllers[i] = NULL;
            result = -1;
        }
    }
{% endif %}

    return result;
}

/* ========================================================================== */
/*  DEVICE UPDATE                                                             */
/* ========================================================================== */

int mavlink_gen_update_all_devices(void) {
    static uint32_t last_time_ms = 0;
    uint32_t current_time_ms = HAL_GetTick();
    float delta_time = (last_time_ms == 0) ? 0.01f : (current_time_ms - last_time_ms) / 1000.0f;
    last_time_ms = current_time_ms;

{% if servo_count > 0 %}
    /* Update servos */
    for (int i = 0; i < MAVLINK_GEN_SERVO_COUNT; i++) {
        if (servo_controllers[i]) {
            motor_update(servo_controllers[i], delta_time);
        }
    }
{% endif %}

{% if dc_motor_count > 0 %}
    /* Update DC motors */
    for (int i = 0; i < MAVLINK_GEN_DC_MOTOR_COUNT; i++) {
        if (dc_motor_controllers[i]) {
            motor_update(dc_motor_controllers[i], delta_time);
        }
    }
{% endif %}

{% if robomaster_count > 0 %}
    /* Update RoboMaster motors */
    for (int i = 0; i < MAVLINK_GEN_ROBOMASTER_COUNT; i++) {
        if (robomaster_controllers[i]) {
            motor_update(robomaster_controllers[i], delta_time);
        }
    }
{% endif %}

{% if rs485_motor_count > 0 %}
    /* Update RS485 motors */
    for (int i = 0; i < MAVLINK_GEN_RS485_MOTOR_COUNT; i++) {
        if (rs485_controllers[i]) {
            motor_update(rs485_controllers[i], delta_time);
        }
    }
{% endif %}

    return 0;
}

/* ========================================================================== */
/*  EMERGENCY STOP                                                            */
/* ========================================================================== */

void mavlink_gen_emergency_stop_all(void) {
{% if servo_count > 0 %}
    /* Stop servos */
    for (int i = 0; i < MAVLINK_GEN_SERVO_COUNT; i++) {
        if (servo_controllers[i]) {
            motor_emergency_stop(servo_controllers[i]);
        }
    }
{% endif %}

{% if dc_motor_count > 0 %}
    /* Stop DC motors */
    for (int i = 0; i < MAVLINK_GEN_DC_MOTOR_COUNT; i++) {
        if (dc_motor_controllers[i]) {
            motor_emergency_stop(dc_motor_controllers[i]);
        }
    }
{% endif %}

{% if robomaster_count > 0 %}
    /* Stop RoboMaster motors */
    for (int i = 0; i < MAVLINK_GEN_ROBOMASTER_COUNT; i++) {
        if (robomaster_controllers[i]) {
            motor_emergency_stop(robomaster_controllers[i]);
        }
    }
{% endif %}

{% if rs485_motor_count > 0 %}
    /* Stop RS485 motors */
    for (int i = 0; i < MAVLINK_GEN_RS485_MOTOR_COUNT; i++) {
        if (rs485_controllers[i]) {
            motor_emergency_stop(rs485_controllers[i]);
        }
    }
{% endif %}
}

/* ========================================================================== */
/*  UNIFIED MOTOR ACCESS                                                      */
/* ========================================================================== */

/**
 * @brief Get motor controller by ID
 * @param motor_id Motor ID (1-255)
 * @return Pointer to motor controller, or NULL if not found
 */
motor_controller_t* mavlink_gen_get_controller_by_id(uint8_t motor_id) {
{% if servo_count > 0 %}
    /* Servo motors: 1-9 */
    if (motor_id >= 1 && motor_id <= 9) {
        for (int i = 0; i < MAVLINK_GEN_SERVO_COUNT; i++) {
            if (servo_controllers[i] && servo_controllers[i]->id == motor_id) {
                return servo_controllers[i];
            }
        }
    }
{% endif %}

{% if dc_motor_count > 0 %}
    /* DC motors: 10-15 */
    if (motor_id >= 10 && motor_id <= 15) {
        for (int i = 0; i < MAVLINK_GEN_DC_MOTOR_COUNT; i++) {
            if (dc_motor_controllers[i] && dc_motor_controllers[i]->id == motor_id) {
                return dc_motor_controllers[i];
            }
        }
    }
{% endif %}

{% if robomaster_count > 0 %}
    /* RoboMaster motors: 20-29 */
    if (motor_id >= 20 && motor_id <= 29) {
        for (int i = 0; i < MAVLINK_GEN_ROBOMASTER_COUNT; i++) {
            if (robomaster_controllers[i] && robomaster_controllers[i]->id == motor_id) {
                return robomaster_controllers[i];
            }
        }
    }
{% endif %}

{% if rs485_motor_count > 0 %}
    /* RS485 motors: 30-49 */
    if (motor_id >= 30 && motor_id <= 49) {
        for (int i = 0; i < MAVLINK_GEN_RS485_MOTOR_COUNT; i++) {
            if (rs485_controllers[i] && rs485_controllers[i]->id == motor_id) {
                return rs485_controllers[i];
            }
        }
    }
{% endif %}

    return NULL;
}
