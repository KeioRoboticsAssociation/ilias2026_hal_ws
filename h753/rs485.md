# Ikeya MD Control RS485 Communication Specification (Final Version)

This document establishes the RS485 communication specification required for Ikeya MD control.
While STM32 HAL programming is assumed, any master side implementation is acceptable.

This specification adopts an **individual address designation method** and aims to control up to 8 slaves.

## Physical Layer

Ikeya MD uses RS485 full-duplex communication (4-wire) as its physical layer.
Therefore, the communication board must also support full-duplex operation.
Note: Encoder resolution is 2048×4

## Application Layer

### Specifications

- Master-slave communication method
    - Master is the board that sends control commands, slave is the Ikeya MD
    - Master ID is 0
    - Ikeya MD has a 4-digit DIP switch configured as follows:
        - **Upper 3 digits**: ID converted from binary to decimal (ID range is 1～8)
        - **Lowest 1 digit**: Control mode selection
            - 0 = Velocity control mode
            - 1 = Position control mode
    - Example: DIP=0010 means ID=1, velocity control mode
    - Example: DIP=0101 means ID=3, position control mode
    - 1:N communication; inter-slave communication is prohibited
- **Communication speed: 500kbps**
- Data length: 8 bits, stop bit length: 1 bit, no parity check
- CRC-16 (Modbus method) included in the latter part of communication
- **Communication method**: Individual address designation
    - Master specifies a particular slave ID for communication
    - Supports two types: READ and WRITE communication

### Protocol

List numbers represent bytes.

---

## READ Communication (Status Reading)

Communication for the master to read the current status of a specific slave

### Master → Slave (READ Request Packet)

1. **Header**: `0xAA` (READ request)
2. **Destination ID**: 1～8
3～4. **CRC-16**: Modbus method (little-endian)

**Total**: 4 bytes

**Transmission time (500kbps)**: 4 bytes × 8 bits ÷ 500,000 bps = **64μs**

---

### Slave → Master (READ Response Packet)

When a slave receives a READ request with its own ID specified, it returns a response according to its control mode.

#### Velocity Control Mode Response

1. **Header**: `0x55` (velocity control response)
2. **Source ID**: 1～8
3～6. **Current RPS**: float type (4 bytes, revolutions per second, little-endian)
7～8. **CRC-16**: Modbus method (little-endian)

**Total**: 8 bytes

**Transmission time (500kbps)**: 8 bytes × 8 bits ÷ 500,000 bps = **128μs**

#### Position Control Mode Response

1. **Header**: `0x56` (position control response)
2. **Source ID**: 1～8
3～4. **count**: int16 type (2 bytes, encoder count value, little-endian)
5～6. **rotation**: int16 type (2 bytes, number of rotations, little-endian)
7～8. **CRC-16**: Modbus method (little-endian)

**Total**: 8 bytes

**Transmission time (500kbps)**: 8 bytes × 8 bits ÷ 500,000 bps = **128μs**

---

## WRITE Communication (Control Command Transmission)

Communication for the master to send control commands to a specific slave.
Both velocity control mode and position control mode use the same header (`0xBB`), and the payload size is unified at 8 bytes.
The slave interprets the received data as either a velocity command or position command according to the control mode set by its DIP switch.

### WRITE for Velocity Control Mode (Master → Slave)

1. **Header**: `0xBB` (WRITE)
2. **Destination ID**: 1～8
3～6. **Target RPS**: float type (4 bytes, revolutions per second, little-endian)
7～8. **CRC-16**: Modbus method (little-endian)

**Total**: 8 bytes

**Transmission time (500kbps)**: 8 bytes × 8 bits ÷ 500,000 bps = **128μs**

### WRITE for Position Control Mode (Master → Slave)

1. **Header**: `0xBB` (WRITE)
2. **Destination ID**: 1～8
3～4. **Target count**: int16 type (2 bytes, encoder count value, little-endian)
5～6. **Target rotation**: int16 type (2 bytes, number of rotations, little-endian)
7～8. **CRC-16**: Modbus method (little-endian)

**Total**: 8 bytes

**Transmission time (500kbps)**: 8 bytes × 8 bits ÷ 500,000 bps = **128μs**

**Note**: The slave interprets the received 4-byte payload appropriately based on its control mode (set by DIP switch).
- Velocity control mode: Interprets bytes 3～6 as float-type RPS
- Position control mode: Interprets bytes 3～4 as count, bytes 5～6 as rotation

---

## Communication Flow

### Initialization Flow
1. Master executes READ communication to all slaves (ID 1～8) at startup
2. Determines each slave's control mode from response header (0x55 or 0x56)
3. Subsequently uses WRITE communication appropriate to each slave's control mode

### Normal Operation Flow
1. Master sends control command to specific slave via WRITE communication
2. Acquires status via READ communication as needed
3. Repeat above steps

---

## Error Handling

- **CRC Error**: 
    - Slave discards packet and maintains previous control command
    - Master retransmits
- **Response Timeout**:
    - If slave response to READ communication is not received within a certain time (e.g., 500μs), judged as communication error
    - If timeout occurs 3 consecutive times, that slave is judged as abnormal
- **Invalid ID**:
    - If ID outside range (0, 9 or above) is received, packet is discarded

---

## Supplementary Information

- **Endianness**: Little-endian (STM32 standard)
- **float type range (RPS)**: Approximately ±3.4×10^38 RPS (IEEE 754 single-precision floating-point)
- **int16 type range (count)**: ±32,767 count
- **int16 type range (rotation)**: ±32,767 rotations
- **Unit conversion**: 
    - RPM → RPS: `RPS = RPM / 60.0`
    - RPS → rad/s: `ω = RPS × 2π ≈ RPS × 6.28318`
- **Response time**: Slave should respond as quickly as possible after receiving READ request (guideline: start transmission within 50μs)

---

## Header List

| Header | Value | Meaning | Direction |
|---------|-----|------|------|
| READ request | 0xAA | Status read request | Master→Slave |
| Velocity control response | 0x55 | Velocity control mode response | Slave→Master |
| Position control response | 0x56 | Position control mode response | Slave→Master |
| WRITE | 0xBB | Control command (common for velocity/position) | Master→Slave |

---

## Data Type Summary

| Item | Type | Size | Range | Unit |
|------|-----|--------|------|------|
| Target RPS | float | 4 bytes | ±3.4×10^38 | RPS (revolutions per second) |
| Current RPS | float | 4 bytes | ±3.4×10^38 | RPS (revolutions per second) |
| count | int16 | 2 bytes | ±32,767 | count |
| rotation | int16 | 2 bytes | ±32,767 | rotations |

---

## Programming Guide

### Structure Definitions

```cpp
// READ request packet
typedef struct {
    uint8_t header;              // 0xAA
    uint8_t id;                  // 1～8
    uint16_t crc;
} __attribute__((packed)) ReadRequestPacket;

// Velocity control response packet
typedef struct {
    uint8_t header;              // 0x55
    uint8_t id;                  // 1～8
    float rps;                   // Current RPS (revolutions per second)
    uint16_t crc;
} __attribute__((packed)) VelocityResponsePacket;

// Position control response packet
typedef struct {
    uint8_t header;              // 0x56
    uint8_t id;                  // 1～8
    int16_t count;               // Encoder count value
    int16_t rotation;            // Number of rotations
    uint16_t crc;
} __attribute__((packed)) PositionResponsePacket;

// WRITE packet (for velocity control)
typedef struct {
    uint8_t header;              // 0xBB
    uint8_t id;                  // 1～8
    float target_rps;            // Target RPS (revolutions per second)
    uint16_t crc;
} __attribute__((packed)) VelocityWritePacket;

// WRITE packet (for position control)
typedef struct {
    uint8_t header;              // 0xBB
    uint8_t id;                  // 1～8
    int16_t target_count;        // Target count
    int16_t target_rotation;     // Target rotation
    uint16_t crc;
} __attribute__((packed)) PositionWritePacket;

// Generic WRITE packet (using common header)
typedef struct {
    uint8_t header;              // 0xBB
    uint8_t id;                  // 1～8
    uint8_t payload[4];          // Velocity or position data
    uint16_t crc;
} __attribute__((packed)) WritePacket;
```

### CRC-16 Calculation Function (Modbus Method)

```cpp
uint16_t calculate_crc16(uint8_t *data, uint16_t length) {
    uint16_t crc = 0xFFFF;
    
    for (uint16_t i = 0; i < length; i++) {
        crc ^= data[i];
        for (uint8_t j = 0; j < 8; j++) {
            if (crc & 0x0001) {
                crc = (crc >> 1) ^ 0xA001;
            } else {
                crc = crc >> 1;
            }
        }
    }
    
    return crc;
}
```

### Using HAL Functions

```cpp
// Transmit
HAL_UART_Transmit(huart, (uint8_t*)&packet, packet_size, Timeout);

// Receive
HAL_UART_Receive(huart, (uint8_t*)&packet, packet_size, Timeout);
```


## Notes

1. **Structure packing**: Use `__attribute__((packed))` to control memory alignment and prevent padding
2. **Endianness**: STM32 is little-endian, so structures can be transmitted/received as-is
3. **Floating-point**: float type is IEEE 754 format, 4 bytes, with sufficient precision
4. **CRC calculation range**: CRC field itself is not included in calculation (from header to end of payload)
5. **Timeout setting**: Set appropriate timeout values according to communication speed